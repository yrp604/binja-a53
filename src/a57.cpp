#define _CRT_SECURE_NO_WARNINGS
#include "binaryninjaapi.h"
#include "lowlevelilinstruction.h"
#include <inttypes.h>
#include <stdio.h>
#include <string.h>

using namespace BinaryNinja;
using namespace std;

// autogenerated static map of key -> msr name
#include "msr.h"

// stolen from il.h
constexpr uint32_t MRS = 20;
constexpr uint32_t MSR = 21;

// Base for our MSRs
constexpr uint32_t MSR_BASE = 0x4200;

class a57: public ArchitectureHook {
private:
  constexpr uint8_t SrOp0(uint32_t ins) { return ((ins >> 19) & 0b1) + 2; }

  constexpr uint8_t SrOp1(uint32_t ins) { return (ins >> 16) & 0b111; }

  constexpr uint8_t SrOp2(uint32_t ins) { return (ins >> 5) & 0b111; }

  constexpr uint8_t SrXt(uint32_t ins) { return ins & 0b11111; }

  constexpr uint8_t SrCm(uint32_t ins) { return (ins >> 8) & 0b1111; }

  constexpr uint8_t SrCn(uint32_t ins) { return (ins >> 12) & 0b1111; }

  constexpr uint32_t StatusReg(uint8_t o0, uint8_t o1, uint8_t Cn, uint8_t Cm,
                               uint8_t o2) {
    return o0 << 14 | o1 << 11 | Cn << 7 | Cm << 3 | o2;
  }

  // If we add all the MSRs to the msr map, it adds 15k registers. This map is
  // checked very frequently during startup and adds considerable slowdown to
  // launch times. As a result, we only only add the named status regsiters,
  // however this means its possible we have an MSR intrinsic with an opcode
  // that references a register we haven't added. As a result, we test when
  // decoding that the Intrinsic is referencing a MSR we've added.
  bool ValidStatusReg(uint8_t o0, uint8_t o1, uint8_t Cn, uint8_t Cm,
                      uint8_t o2) {
    const uint32_t key = StatusReg(o0, o1, Cn, Cm, o2);

    return msr.find(key) != msr.end();
  }

  const char *StatusRegName(uint32_t key) { return msr[key]; }

  // we need a shotgun arm64 decoder
  constexpr uint32_t DecodeIntrinsic(const uint8_t *data, size_t sz) {
    if (sz < 4)
      return 0;

    const uint32_t candidate = *(uint32_t *)data;

    if (candidate >> 20 == 0b110101010001)
      if (ValidStatusReg(SrOp0(candidate), SrOp1(candidate), SrCn(candidate),
                         SrCm(candidate), SrOp2(candidate)))
        return MSR;

    const uint32_t msr_imm = 0b11010101000000000100000000011111;
    const uint32_t msr_imm_mask = 0b11010101000000000100000000011111;
    if ((candidate & msr_imm_mask) == msr_imm) {
      if (ValidStatusReg(SrOp0(candidate), SrOp1(candidate), SrCn(candidate),
                         SrCm(candidate), SrOp2(candidate)))
        return MSR;
    }

    if (candidate >> 20 == 0b110101010011)
      if (ValidStatusReg(SrOp0(candidate), SrOp1(candidate), SrCn(candidate),
                         SrCm(candidate), SrOp2(candidate)))
        return MRS;

    return 0;
  }

public:
  a57(Architecture *arm64) : ArchitectureHook(arm64) {}

  /*
   * First we need to add all the status registers as registers to the
   * architecture so that our intrinsics have a src (mrs) and a dst (msr)
   */
  virtual vector<uint32_t> GetAllRegisters() override {
    vector<uint32_t> regs = ArchitectureHook::GetAllRegisters();

    for (auto const &ii : msr) {
      regs.push_back(MSR_BASE + ii.first);
    }

    return regs;
  }

  virtual vector<uint32_t> GetSystemRegisters() override {
    vector<uint32_t> regs = ArchitectureHook::GetSystemRegisters();

    for (auto const &ii : msr) {
      regs.push_back(MSR_BASE + ii.first);
    }

    return regs;
  }

  virtual string GetRegisterName(uint32_t reg) override {
    uint32_t key = reg - MSR_BASE;

    if (msr.find(key) != msr.end()) {
      return StatusRegName(key);
    }

    return ArchitectureHook::GetRegisterName(reg);
  }

  virtual BNRegisterInfo GetRegisterInfo(uint32_t reg) override {
    uint32_t key = reg - MSR_BASE;

    if (msr.find(key) != msr.end()) {
      BNRegisterInfo res;

      res.fullWidthRegister = reg;
      res.offset = 0;
      res.size = 8;
      res.extend = NoExtend;

      return res;
    }

    return ArchitectureHook::GetRegisterInfo(reg);
  }

  virtual vector<uint32_t> GetFullWidthRegisters() override {
    vector<uint32_t> regs = ArchitectureHook::GetFullWidthRegisters();

    for (auto const &ii : msr) {
      regs.push_back(MSR_BASE + ii.first);
    }

    return regs;
  }

  virtual bool GetInstructionLowLevelIL(const uint8_t *data, uint64_t addr,
                                        size_t &len,
                                        LowLevelILFunction &il) override {
    switch (DecodeIntrinsic(data, len)) {
    case MSR: {
      uint32_t ins = *(uint32_t *)data;

      il.AddInstruction(il.Intrinsic(
          vector<RegisterOrFlag>{
              RegisterOrFlag::Register(
                  MSR_BASE + StatusReg(SrOp0(ins), SrOp1(ins), SrCn(ins),
                                       SrCm(ins), SrOp2(ins))),
          },
          MSR,
          // 34 is the offset into the 64b GPRs from GetAllRegisters
          vector<ExprId>{il.Register(8, 34 + SrXt(ins))}));
      break;
    }
    case MRS: {
      uint32_t ins = *(uint32_t *)data;

      il.AddInstruction(il.Intrinsic(
          // 34 is the offset into the 64b GPRs from GetAllRegisters
          vector<RegisterOrFlag>{RegisterOrFlag::Register(34 + SrXt(ins))}, MRS,
          vector<ExprId>{
              il.Register(4, MSR_BASE + StatusReg(SrOp0(ins), SrOp1(ins),
                                                  SrCn(ins), SrCm(ins),
                                                  SrOp2(ins))),
          }));
      break;
    }
    // intrinsic not found, punt to the arch plugin
    case 0:
    default:
      return ArchitectureHook::GetInstructionLowLevelIL(data, addr, len, il);
    }

    len = 4; // all instructions are 4b
    return true;
  }
};

extern "C" {
BN_DECLARE_CORE_ABI_VERSION

BINARYNINJAPLUGIN void CorePluginDependencies() {
  // Make sure we load after the original arm64 plugin loads
  AddRequiredPluginDependency("arch_arm64");
}

BINARYNINJAPLUGIN bool CorePluginInit() {
  // binja uses both arm64 and aarch64, so we just pick one and use it
  Architecture *a57_hook = new a57(Architecture::GetByName("aarch64"));
  Architecture::Register(a57_hook);
  return true;
}
}
